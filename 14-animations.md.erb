---
title: 애니메이션
slug: animations
date: 0014/01/01
number: 14
contents: 미티어가 두 DOM 엘리먼트를 자리바꿀 때, 내부에서 일어나는 일을 살펴본다.|Post 목록의 재정렬을 애니메이션하는 방법을 배운다.|새로운 post의 삽입을 애니메이션하는 방법을 배운다.
paragraphs: 58
---

이제 실시간 투표, 점수 계산, 순위 지정을 하는 기능이 구현되었다. 그런데, 홈페이지에서 post가 점프하여 이동하는 사용자 경험이 거슬리고, 이상하다. 이를 애니메이션으로 부드럽게 처리하려고 한다.

### 미티어와 DOM

흥미로운 분야(움직이는 세계)로 나가기에 앞서 미티어가 DOM(Document Object Model – 페이지를 구성하는 HTML 엘리먼트들의 컬렉션)과 어떻게 상호작용을 하는 지 이해할 필요가 있다.

명심해야 할 결정적인 포인트는 엘리먼트들은 *이동할 수 없다*는 것이다. 이들은 삭제되거나 생성(이것은 DOM의 한계이지 미티어의 한계가 아니다)될 수만 있다. 그러므로, A와 B가 자리를 바꾸는 모양을 만들어 내기 위해서, 미티어는 실제로는 B를 제거하고 B의 새 복제물을 A앞에 삽입하는 것이다.

이런 기교를 부리는 것은, B를 새 위치로 애니메이션하여 이동하지 못하기 때문이다. B는 미티어가 페이지를 다시 그리는 순간(이것은 반응성 덕분에 순간적으로 일어난다) 사라진다. 대신 새로 생성된 B가 원래 위치에서 A의 앞에 이동하는 것이다.

post A와 post B를 바꿔치기 위해서(상대적으로 p1, p2에 위치해 있다고 하면), 다음 단계를 따라갈 것이다:

1. B를 삭제한다
2. DOM에서 A 앞에 B'를 생성한다
3. B'를 p2로 이동한다
4. A를 p1으로 이동한다
5. A를 p2로 애니메이션 처리한다
6. B'를 p1으로 애니메이션 처리한다

아래 다이어그램은 위의 단계를 상세하게 설명해준다:

<%= diagram "animation_diagram", "Swtiching two posts", "pull-center" %>

3, 4단계는 A와 B를 *애니메이션*으로 처리하는 것이 아니라 순간적으로 "공간이동"시킨다. 이것이 순간적으로 일어나기 때문에 B가 삭제되지 않고 두 요소가 새 위치로 적절하게 자리하는 착각을 준다.

다행히, 미티어가 1, 2단계는 알아서 한다. 그래서 우리는 3단계에서 6단계까지만 걱정하면 된다.

더욱이, 5, 6단계에서 우리가 할 일은 그 요소들을 적절한 자리로 이동시키는 것이다. 그러므로 우리가 정말로 걱정할 부분은 3, 4단계로 요소들을 에니메이션의 시작위치로 보내는 것 뿐이다.


### 적절한 타이밍

지금까지 우리는 post를 애니메이션 하는 *방법*에 대하여 논의를 했을 뿐 *시간*에 대하여는 논의하지 않았다.

3, 4단계에 대하여는 해법은 `post_item.js` 매니저에 있는 미티어의 `rendered` 템플릿 콜백에 있다. 이 콜백은 post의 속성(우리의 경우 순위)이 변하면 어느 때나 구동된다.

5와 6단계는 다소 기교를 부려야 한다. 이런 방식으로 생각해보자: 완벽하게 논리적인 로붓에게 북쪽으로 5분간 달린 다음, 다시 남쪽으로 5분간 달리라고 지시하면, 로봇은 추론을 하기를 결국 같은 자리에 있게 되니까 에너지를 아껴 그냥 달리지 않을 것이다.

그래서 만약 로봇이 10분간을 달리도록 하려면, 처음 5분을 달리기가 완료될 때까지 기다려야 한다. 그리고 달렸으면 다시 돌아오라고 지시해야 한다.

브라우저도 비슷하게 작동한다: 만약 두 지시를 동시에 하면 새 좌표는 단지 옛 좌표를 바꿔치기 할 뿐 아무 일도 일어나지 않는다. 다른 말로 표현하면, 브라우저는 위치의 변경을 시간상에서 다른 점에서 등록해야 한다. 그렇지 않으면 애니메이션이 일어나지 않는다.

미티어는 `justAfterRendered` 콜백을 제공하지 않는다. 하지만, 우리는 `Meteor.defer()`를 이용하여 이를 속일 수 있는데, 이 함수는 완전히 다른 이벤트로 등록하기 충분할 정도로 실행을 연기한다.

### CSS 위치 지정

Post 목록이 페이지 내에서 재정렬되는 것을 애니메이션으로 처리하기 위해서는 CSS 영역에 도전해야 한다. CSS 위치 지정에 대한 빠른 훑어보기가 다음 순서다.

페이지에서 엘리먼트는 초기값으로 **static** position으로 설정되어 있다. Static position 상태의 엘리먼트는 페이지의 흐름에 맞춘다. 화면에서 그 좌표는 변경되거나 애니메이션이 될 수 없다.

한 편, **relative** position은 엘리먼트 페이지 흐름에 맞추지만, 그 *원래 위치에 상대적으로* 자리한다.

**Absolute** position은 한 단계 더 나아가서 엘리먼트에게 **도큐먼트**나 또는 **첫 번째 absolute 또는 relative-position상태의 부모 엘리먼트**에 상대적으로 특정한 x/y 좌표로 위치한다.

Post의 애니메이션에는 relative position을 사용할 것이다. 이미 CSS를 제공했지만, 직접 해보고 싶다면 아래 코드를 스타일 시트에 추가하면 된다:

~~~css
.post{
  position:relative;
  transition:all 300ms 0ms ease-in;
}
~~~
<%= caption "client/stylesheets/style.css" %>

이렇게 하면 5와 6단계는 매우 쉽게 구현된다: 우리가 할 일은 `top`을 `0px`로 지정(초기 설정값이다)하면 post들은 그 "normal" 위치로 미끄러져 되돌아 갈 것이다.

우리에게 유일한 도전과제는 애니메이션을 구동할 위치(3, 4단계)를 *새 위치에 상대적인 좌표로* 지정하는 것이다. 다른 말로 표현하면, 그들의 위치를 얼마나 변이(offset)시키는 가이다. 하지만, 이것이 아주 어려운 것은 아니다: 올바른 위치 이동폭은 단순히 post의 이전 위치에서 새 위치를 빼면 된다.

<% note do %>

### Position:absolute

엘리먼트의 위치를 지정하는데 부모 엘리먼트에 상대적으로 `position:absolute`를 사용할 수 있다. 하지만 절대 좌표를 사용하는 엘리먼트의 큰 단점은 페이지의 흐름으로부터 완전히 빠지게 되어, 이것이 비게 되면 그 부모 컨테이너가 공간을 잃게 된다는 점이다.

결국 이 의미는 JavaScript를 통해서 인위적으로 그 컨테이너의 height를 지정해야 한다는 것이고, 브라우저의 엘리먼트 재정렬 기능에서 자연스럽게 빠지게 된다. 결과적으로 가능하다면 relative position을 고수하는 것이 최선이다.

<% end %>

### 토탈 리콜

아직 한 가지 문제가 더 남았다. DOM에서 엘리먼트 A는 저장되어 그 이전의 위치를 "기억"하고 있는 반면, 엘리먼트 B는 새로 만들어져서 B'로 돌아왔기에 그 기억은 완전히 지워진 상태가 된다.

다행히 미티어는 `rendered` 콜백에서 **템플릿 인스턴스** 객체에 대한 접근이 가능하다. 이에 대한 [미티어 문서](http://docs.meteor.com/#template_rendered)에는 다음과 같은 내용이 있다:

> 콜백 내부에서, `this`는 템플릿의 구동에 유일하고 다시 렌더링과정에서도 유지되는 템플릿 인스턴스 객체이다.

그러므로 우리가 할 일은 페이지에서 post의 현재 위치를 찾는 것이다. 그리고 찾은 다음에 템플릿 인스턴스 객체에 그 위치를 저장한다. 이 방법을 사용하여 post가 삭제되거나 새로 만들어진다 해도 우리는 애미메이션을 시작할 위치를 알 수 있게 된다.

템플릿 인스턴스에서는 `data` 속성을 이용하여 컬렉션 데이터에 접근할 수 있다. 이것으로 post의 순위를 다루게 될 것이다.

### Post 순위 매기기

그 동안 post의 순위에 대하여 이야기해왔는데 이 "순위"는 post의 속성으로 실제 존재하는 것은 아니다. 이것은 단지 컬렉션에서 post목록이 정렬되는 것의 결과일 뿐이다. 이 순위에 따라서 post 목록을 애니메이션 처리하려고 한다면, 얇은 틈에서 이 속성을 만들어내어야 할 것이다.

유의할 사항은 데이터베이스에 이 `rank` 속성을 넣을 수 없다는 것이다. 왜냐면, 이것은 post 목록을 정렬하는 방법(즉, post는 처음에는 날짜에 의해 순위가 정해지지만, 세 번째에는 포인트에 의해서 정렬된다)에 의존하는 상대적 속성이기 때문이다.

이상적으로는 `newPosts`와 `topPosts` 컬렉션에 그 속성을 넣는 것이지만, 미티어는 아직은 이 부분에 대한 쉬운 방법을 제공하지 않는다.

그래서 대신에, `rank`를 마지막 가능한 단계인, `postList` 템플릿 매니저에 삽입할 것이다:

~~~js
Template.postsList.helpers({
  postsWithRank: function() {
    this.posts.rewind();
    return this.posts.map(function(post, index, cursor) {
      post._rank = index;
      return post;
    });
  }
});
~~~
<%= caption "/client/views/posts/posts_list.js" %>
<%= highlight "2~8" %>

단순히 이전의 `posts` 헬퍼와 같은 커서인 `Posts.find({}, {sort: {submitted: -1}, limit: postsHandle.limit()})`을 리턴하는 대신에 `postsWithRank`는 커서로부터 각 도큐먼트에 `_rank` 속성을 추가한다.

`postsList` 템플릿을 다음과 같이 갱신하는 것을 잊지말라:

~~~html
<template name="postsList">
  <div class="posts">
    {{#each postsWithRank}}
      {{> postItem}}
    {{/each}}
    
    {{#if nextPath}}
      <a class="load-more" href="{{nextPath}}">Load more</a>
    {{/if}}
  </div>
</template>
~~~
<%= caption "/client/views/posts/posts_list.html" %>

<%= highlight "3" %>

<% note do %>

### 친절한 Rewind

미티어는 가장 유망한 첨단의 웹 프레임워크중 하나다. 하지만 이 기능 중의 하나는 VCR과 비디오 카세트 녹음기의 시대로 되돌아가는 듯한 느낌을 주는 이름의 rewind() 함수이다.

`forEach()`, `map()`, 또는 `fetch()`로 커서를 사용할 때면, 이것이 다시 사용하기 전에 커서를 rewind할 필요가 있다.

그리고 경우에 따라서, 안전한 방향으로 선택하고 버그의 위험보다는 예방적으로 커서를 `rewind()`하는 것이 낫다.

<% end %>

### 모두 모아서

이제 애니메이션 로직에 대하여 `post_item.js` 매니저의 `rendered` 템플릿 콜백을 사용하여 모두 모아서 구현한다:

~~~js
Template.postItem.helpers({
  //...
});

Template.postItem.rendered = function(){
  // animate post from previous position to new position
  var instance = this;
  var rank = instance.data._rank;
  var $this = $(this.firstNode);
  var postHeight = 80;
  var newPosition = rank * postHeight;
 
  // if element has a currentPosition (i.e. it's not the first ever render)
  if (typeof(instance.currentPosition) !== 'undefined') {
    var previousPosition = instance.currentPosition;
    // calculate difference between old position and new position and send element there
    var delta = previousPosition - newPosition;
    $this.css("top", delta + "px");
  }
  
  // let it draw in the old position, then..
  Meteor.defer(function() {
    instance.currentPosition = newPosition;
    // bring element back to its new original position
    $this.css("top",  "0px");
  }); 
};

Template.postItem.events({
  //...
});
~~~
<%= caption "/client/views/posts/post_item.js" %>
<%= highlight "5~27" %>

<%= commit "14-1", "Added post reordering animation." %>

이전의 다이아그램으로 돌아가서 참조하면 계속 따라가는 것이 그리 어렵지만은 않을 것이다.

`defer` 콜백에서 템플릿 인스턴스의 `currentPosition` 속성을 지정했으므로, 이 속성은 템플릿 조각의 첫 번째 렌더링에는 존재하지 않을 거라는 의미가 된다. 그러나 이것이 문제는 아닌것이 우리는 어쨋거나 그 첫 번째 렌더링을 애니메이션 하는 것에는 관심이 없기 때문이다.

이제 사이트를 열고 투표를 해보자. post 목록이 우아한 발레처럼 부드럽게 움직이는 것을 볼 것이다!

### 새 Post에 애니메이션 적용하기

이제 Post 목록은 적절하게 재정렬한다. 그러나 우리는 아직 "새 post"에 대한 애니메이션은 적용하지 않았다. 새 post가 목록의 상단에 단순하게 확 나타나는 대신에 서서히 나타나게 해보자.

이것은 생각보다는 더 복잡하다. 문제는 미티어의 `rendered` 콜백이 실제로는 두 가지 경우에 구동된다는 점이다:

1. 새로운 템플릿이 DOM에 삽입될 때
2. 템플릿의 데이터가 변경될 때

만약 사용자 인터페이스가 데이터가 변경될 때마다 크리스마스 트리처럼 반짝이기를 원하지 않는다면, 첫 번째 경우에만 애니메이션이 일어난다.

그러므로 데이터가 변경되어서 새로 렌더링되는 경우가 아니라, 실제로 새 post일 때에 한하여 애니메이션을 적용하기로 하자. 우리는 이미 instance 변수(이것은 첫 번째 렌더링 후에만 설정된다)의 존재를 테스트하고 있다. 그러므로 `rendered` 콜백으로 돌아가서 else 블록을 추가한다:

~~~js
Template.postItem.helpers({
  //...
});

Template.postItem.rendered = function(){
  // animate post from previous position to new position
  var instance = this;
  var rank = instance.data._rank;
  var $this = $(this.firstNode);
  var postHeight = 80;
  var newPosition = rank * postHeight;
  
  // if element has a currentPosition (i.e. it's not the first ever render)
  if (typeof(instance.currentPosition) !== 'undefined') {
    var previousPosition = instance.currentPosition;
    // calculate difference between old position and new position and send element there
    var delta = previousPosition - newPosition;
    $this.css("top", delta + "px");
  } else {
    // it's the first ever render, so hide element
    $this.addClass("invisible");
  }
  
  // let it draw in the old position, then..
  Meteor.defer(function() {
    instance.currentPosition = newPosition;
    // bring element back to its new original position
    $this.css("top",  "0px").removeClass("invisible");
  }); 
};

Template.postItem.events({
  //...
});
~~~
<%= caption "/client/views/posts/post_item.js" %>
<%= highlight "19~22,28" %>

<%= commit "14-2", "Fade items in when they are drawn." %>

`defer()` 함수에 추가한 `removeClass("invisible")`는 모든 렌더링에서 실행되는 것에 주목하라. 그러나 이것은 엘리먼트에 `.invisible` 클래스가 실제로 존재할 때에만 작동하는 데, 이 경우는 처음 렌더링될 때에만 true이다.

<% note do %>

### CSS와 JavaScript

우리는 `top`에 대하여 했던 것처럼 CSS `opacity` 속성을 직접 애니메이션 적용하는 대신에 애니메이션을 구동하기 위해 `.invisible` CSS 클래스를 사용하고 있다. `top`의 경우에는 인스턴스 데이터에 의존하는 특정한 값을 속성에 애니메이션으로 적용해야 했기 때문이다.

다른 한 편, 여기서는 그 데이터에 무관하게 엘리먼트를 보이거나 감추기만을 원한다. 가능한 많이 JavaScript를 CSS에서 배제하는 것이 바람직하므로, 우리는 여기서 클래스를 추가하거나 제거하기만 하며 애니메이션의 상세 내용은 스타일 시트에 지정한다.
<% end %>

우리는 마침내 우리가 원하는 애니메이션을 모두 구현했다. 앱을 구동하여 시도해보라! 그리고 다른 transition을 해보고 싶다면 `.post`와 `.post.invisible` 클래스로 이런 저런 시도를 해 볼 수 있다. 힌트: [CSS easing functions](http://matthewlein.com/ceaser/)이 좋은 출발점이다!
