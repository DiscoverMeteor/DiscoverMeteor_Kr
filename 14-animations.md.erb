---
title: 애니메이션
slug: animations
date: 0014/01/01
number: 14
contents: 미티어가 두 DOM 엘리먼트를 자리바꿀 때, 은연중에 무슨 일이 일어나는 지를 알아본다.|Post 목록의 재정렬을 애니메이션하는 방법을 배운다.|새로운 post의 삽입을 애니메이션하는 방버을 배운다.
paragraphs: 58
---

이제 실시간 투표, 점수 계산, 순위 지정을 하는 기능이 구현되었다. 그런데, 홈페이지에서 post가 점프하여 이동하는 사용자 경험이 거슬리고, 이상하다. 이를 애니메이션으로 부드럽게 처리하려고 한다.

### 미티어와 DOM

흥미로운 분야(움직이는 세계)로 나가기에 앞서 미티어가 DOM(Document Object Model – 페이지를 구성하는 HTML 엘리먼트들의 컬렉션)과 어떻게 상호작용을 하는 지 이해할 필요가 있다.

명심해야 할 결정적인 포인트는 엘리먼트들은 *이동할 수 없다*는 것이다. 이들은 삭제되거나 생성(이것은 DOM의 한계이지 미티어의 한계가 아니다)될 수만 있다. 그러므로, A와 B가 자리를 바꾸는 모양을 만들어 내기 위해서, 미티어는 실제로는 B를 제거하고 B의 새 복제물을 A앞에 삽입하는 것이다.

이런 기교를 부리는 것은, B를 새 위치로 애니메이션하여 이동하지 못하기 때문이다. B는 미티어가 페이지를 다시 그리는 순간(이것은 반응성 덕분에 순간적으로 일어난다) 사라진다. 대신 새로 생성된 B가 원래 위치에서 A의 앞에 이동하는 것이다.

post A와 post B를 바꿔치기 위해서(상대적으로 p1, p2에 위치해 있다고 하면), 다음 단계를 따라갈 것이다:

1. B를 삭제한다
2. DOM에서 A 앞에 B'를 생성한다
3. B'를 p2로 이동한다
4. A를 p1으로 이동한다
5. A를 p2로 애니메이션 처리한다
6. B'를 p1으로 애니메이션 처리한다

아래 다이어그램은 위의 단계를 상세하게 설명해준다:

<%= diagram "animation_diagram", "Swtiching two posts", "pull-center" %>

3, 4단계는 A와 B를 *애니메이션*으로 처리하는 것이 아니라 순간적으로 "공간이동"시킨다. 이것이 순간적으로 일어나기 때문에 B가 삭제되지 않고 두 요소가 새 위치로 적절하게 자리하는 착각을 준다.

다행히, 미티어가 1, 2단계는 알아서 한다. 그래서 우리는 3단계에서 6단계까지만 걱정하면 된다.

더욱이, 5, 6단계에서 우리가 할 일은 그 요소들을 적절한 자리로 이동시키는 것이다. 그러므로 우리가 정말로 걱정할 부분은 3, 4단계로 요소들을 에니메이션의 시작위치로 보내는 것 뿐이다.

### 적절한 타이밍

지금까지 우리는 post를 애니메이션 하는 *방법*에 대하여 논의를 했을 뿐 *시간*에 대하여는 논의하지 않았다.

3, 4단계에 대하여는 해법은 `post_item.js` 매니저에 있는 미티어의 `rendered` 템플릿 콜백에 있다. 이 콜백은 post의 속성(우리의 경우 순위)이 변하면 어느 때나 구동된다.

5와 6단계는 다소 기교를 부려야 한다. 이런 방식으로 생각해보자: 완벽하게 논리적인 로붓에게 북쪽으로 5분간 달린 다음, 다시 남쪽으로 5분간 달리라고 지시하면, 로봇은 추론을 하기를 결국 같은 자리에 있게 되니까 에너지를 아껴 그냥 달리지 않을 것이다.

그래서 만약 로봇이 10분간을 달리도록 하려면, 처음 5분을 달리기가 완료될 때까지 기다려야 한다. 그리고 달렸으면 다시 돌아오라고 지시해야 한다.

브라우저도 비슷하게 작동한다: 만약 두 지시를 동시에 하면 새 좌표는 단지 옛 좌표를 바꿔치기 할 뿐 아무 일도 일어나지 않는다. 다른 말로 표현하면, 브라우저는 위치의 변경을 시간상에서 다른 점에서 등록해야 한다. 그렇지 않으면 애니메이션이 일어나지 않는다.

미티어는 `justAfterRendered` 콜백을 제공하지 않는다. 하지만, 우리는 `Meteor.defer()`를 이용하여 이를 속일 수 있는데, 이 함수는 완전히 다른 이벤트로 등록하기 충분할 정도로 실행을 연기한다.

### CSS 위치 지정

Post 목록이 페이지 내에서 재정렬되는 것을 애니메이션으로 처리하기 위해서는 CSS 영역에 도전해야 한다. CSS 위치 지정에 대한 빠른 훑어보기가 다음 순서다.

페이지에서 엘리먼트는 초기값으로 **static** position으로 설정되어 있다. Static position 상태의 엘리먼트는 페이지의 흐름에 맞춘다. 화면에서 그 좌표는 변경되거나 애니메이션이 될 수 없다.

한 편, **relative** position은 엘리먼트 페이지 흐름에 맞추지만, 그 *원래 위치에 상대적으로* 자리한다.

**Absolute** position은 한 단계 더 나아가서 엘리먼트에게 **도큐먼트**나 또는 **첫 번째 absolute 또는 relative-position상태의 부모 엘리먼트**에 상대적으로 특정한 x/y 좌표로 위치한다.

Post의 애니메이션에는 relative position을 사용할 것이다. 이미 CSS를 제공했지만, 직접 해보고 싶다면 아래 코드를 스타일 시트에 추가하면 된다:

~~~css
.post{
  position:relative;
  transition:all 300ms 0ms ease-in;
}
~~~
<%= caption "client/stylesheets/style.css" %>

////

////

<% note do %>

### Position:absolute

////

////

<% end %>

### Total Recall

////

////

> //// 

////

////

### Ranking Posts

////

////

////

////

~~~js
Template.postsList.helpers({
  postsWithRank: function() {
    this.posts.rewind();
    return this.posts.map(function(post, index, cursor) {
      post._rank = index;
      return post;
    });
  }
});
~~~
<%= caption "/client/views/posts/posts_list.js" %>
<%= highlight "2~8" %>

////

////

~~~html
<template name="postsList">
  <div class="posts">
    {{#each postsWithRank}}
      {{> postItem}}
    {{/each}}
    
    {{#if nextPath}}
      <a class="load-more" href="{{nextPath}}">Load more</a>
    {{/if}}
  </div>
</template>
~~~
<%= caption "/client/views/posts/posts_list.html" %>

<%= highlight "3" %>

<% note do %>

### Be Kind, Rewind

////

////

////

<% end %>

### Putting it together

////

~~~js
Template.postItem.helpers({
  //...
});

Template.postItem.rendered = function(){
  // animate post from previous position to new position
  var instance = this;
  var rank = instance.data._rank;
  var $this = $(this.firstNode);
  var postHeight = 80;
  var newPosition = rank * postHeight;
 
  // if element has a currentPosition (i.e. it's not the first ever render)
  if (typeof(instance.currentPosition) !== 'undefined') {
    var previousPosition = instance.currentPosition;
    // calculate difference between old position and new position and send element there
    var delta = previousPosition - newPosition;
    $this.css("top", delta + "px");
  }
  
  // let it draw in the old position, then..
  Meteor.defer(function() {
    instance.currentPosition = newPosition;
    // bring element back to its new original position
    $this.css("top",  "0px");
  }); 
};

Template.postItem.events({
  //...
});
~~~
<%= caption "/client/views/posts/post_item.js" %>
<%= highlight "5~27" %>

<%= commit "14-1", "Added post reordering animation." %>

////

////

////

### Animating New Posts

////

////

1. ////
2. ////

////

////

~~~js
Template.postItem.helpers({
  //...
});

Template.postItem.rendered = function(){
  // animate post from previous position to new position
  var instance = this;
  var rank = instance.data._rank;
  var $this = $(this.firstNode);
  var postHeight = 80;
  var newPosition = rank * postHeight;
  
  // if element has a currentPosition (i.e. it's not the first ever render)
  if (typeof(instance.currentPosition) !== 'undefined') {
    var previousPosition = instance.currentPosition;
    // calculate difference between old position and new position and send element there
    var delta = previousPosition - newPosition;
    $this.css("top", delta + "px");
  } else {
    // it's the first ever render, so hide element
    $this.addClass("invisible");
  }
  
  // let it draw in the old position, then..
  Meteor.defer(function() {
    instance.currentPosition = newPosition;
    // bring element back to its new original position
    $this.css("top",  "0px").removeClass("invisible");
  }); 
};

Template.postItem.events({
  //...
});
~~~
<%= caption "/client/views/posts/post_item.js" %>
<%= highlight "19~22,28" %>

<%= commit "14-2", "Fade items in when they are drawn." %>

////

<% note do %>

### CSS & JavaScript

////

////

<% end %>

////
